version: "3"

vars:
  K8S_VERSION: v1.33.0

env:
  HELM_DATA_HOME: "{{.HOME}}/.local/share/helm"

tasks:
  dev:start:
    cmds:
      - minikube start --kubernetes-version={{.K8S_VERSION}}
      - minikube addons enable ingress
      - minikube addons enable ingress-dns
      - task: set-context

  dev:stop:
    cmds:
      - minikube stop

  dev:reset:
    cmds:
      - minikube delete

  set-context:
    desc: Set kubectl default namespace to celine
    cmds:
      - kubectl config use-context minikube
      - kubectl config set-context --current --namespace=celine-dev

  helm:apply:*:
    vars:
      DEPLOYMENT_ENV: "{{ index .MATCH 0 }}"
      ARGS: "{{ .CLI_ARGS }}"
    env:
      SOPS_AGE_KEY_FILE: "{{ .PWD }}/.sops/{{ .DEPLOYMENT_ENV }}/key.txt"
    cmds:
      - |
        if [ -z "{{ .ARGS }}" ]; then
          echo "Error: missing filter argument (e.g. name=chart1)"
          exit 1
        fi
        helmfile -e {{ .DEPLOYMENT_ENV }} -l {{ .ARGS }} apply

  helm:destroy:*:
    vars:
      DEPLOYMENT_ENV: "{{ index .MATCH 0 }}"
      ARGS: "{{ .CLI_ARGS }}"
    env:
      SOPS_AGE_KEY_FILE: "{{ .PWD }}/.sops/{{ .DEPLOYMENT_ENV }}/key.txt"
    cmds:
      - |
        if [ -z "{{ .ARGS }}" ]; then
          echo "Error: missing filter argument (e.g. name=chart1)"
          exit 1
        fi
        helmfile -e {{ .DEPLOYMENT_ENV }} -l {{ .ARGS }} destroy

  helmfile:*:
    vars:
      DEPLOYMENT_ENV: "{{ index .MATCH 0 }}"
    env:
      SOPS_AGE_KEY_FILE: "{{.PWD}}/.sops/{{.DEPLOYMENT_ENV}}/key.txt"
    cmds:
      - |
        if [ ! -d "./envs/{{.DEPLOYMENT_ENV}}" ]; then \
          echo "Environment ./envs/{{.DEPLOYMENT_ENV}} not found"
          exit 1
        fi
      - helmfile -e {{.DEPLOYMENT_ENV}} {{.CLI_ARGS}}

  apply:
    env:
      SOPS_AGE_KEY_FILE: "{{.PWD}}/.sops/{{.CLI_ARGS}}/key.txt"
    cmds:
      - |
        if [ ! -d "./envs/{{.CLI_ARGS}}" ]; then \
          echo "Environment ./envs/{{.CLI_ARGS}} not found"
          exit 1
        fi
      - helmfile -e {{.CLI_ARGS}} -l name=cnpg apply
      - helmfile -e {{.CLI_ARGS}} -l group=core apply
      - helmfile -e {{.CLI_ARGS}} -l group=auth apply
      - helmfile -e {{.CLI_ARGS}} -l group=apps apply
      - helmfile -e {{.CLI_ARGS}} -l group=pipelines apply
      - helmfile -e {{.CLI_ARGS}} -l group=celine-services apply

  apply:dev:
    deps:
      - sops:copy-dev-keys
      - set-context
    cmds:
      - task apply -- dev

  mqtt:passwd:
    cmds:
      - |
        FILE=$(mktemp)
        mosquitto_passwd -H sha512-pbkdf2 -c $FILE USERNAME
        cut -d ":" -f 2 $FILE
        rm $FILE

  postgres:forward:
    cmds:
      - kubectl port-forward svc/postgis1-rw 5432:5432

  sops:encrypt:
    desc: Encrypt secrets.yaml -> secrets.sops.yaml (per-env key)
    cmds:
      - |
        set -e
        shopt -s nullglob
        for f in envs/*/secrets.yaml; do
          env=$(basename "$(dirname "$f")")
          key=".sops/$env/key.txt"
          out="${f%.yaml}.sops.yaml"

          if [ ! -f "$key" ]; then
            echo "Missing key for $env ($key), skipping"
            continue
          fi

          echo "Encrypting $f → $out"
          SOPS_AGE_KEY_FILE="$key" sops --encrypt "$f" > "$out"
        done
        shopt -u nullglob

  sops:decrypt:
    desc: Decrypt secrets.sops.yaml -> secrets.yaml (per-env key)
    cmds:
      - |
        set -e
        for f in envs/*/secrets.sops.yaml; do
          env=$(basename "$(dirname "$f")")
          key=".sops/$env/key.txt"
          out="${f%.sops.yaml}.yaml"

          if [ ! -f "$key" ]; then
            echo "Missing key for $env ($key), skipping"
            continue
          fi

          # --- Backup existing secrets.yaml if present ---
          if [ -f "$out" ]; then
            ts=$(date +"%Y%m%d%H%M")
            backup="${out}.${ts}"
            echo "Backing up existing $out -> $backup"
            cp "$out" "$backup"

            # Keep only last 5 backups
            backups=( $(ls -1t "${out}".20* 2>/dev/null || true) )
            if [ ${#backups[@]} -gt 5 ]; then
              to_delete=( "${backups[@]:5}" )
              echo "Pruning old backups:"
              for del in "${to_delete[@]}"; do
                echo "  removing $del"
                rm -f "$del"
              done
            fi
          fi


          echo "Decrypting $f → $out"
          SOPS_AGE_KEY_FILE="$key" sops --decrypt "$f" > "$out"
        done

  sops:create-env:
    desc: Create a new environment and AGE key (adds to .sops.yaml)
    cmds:
      - |
        set -e
        ENV={{.CLI_ARGS}}
        test -n "$ENV" || { echo "Usage: task sops:create-env <env>"; exit 1; }

        keydir=".sops/$ENV"
        keyfile="$keydir/key.txt"

        if [ -d "$keydir" ]; then
          echo "Environment '$ENV' already exists."
          exit 1
        fi

        mkdir -p "$keydir"
        age-keygen -o "$keyfile" > /dev/null

        # create stub folder
        mkdir -p "./envs/$ENV"
        SEC=./envs/$ENV/secrets.yaml
        if [ ! -f $SEC ]; then
          echo "---" > $SEC
          echo "Created stub secret $SEC"
        fi
        VAL=./envs/$ENV/values.yaml
        if [ ! -f $VAL ]; then
          cp ./envs/dev/values.yaml $VAL
          echo "Created stub file $VAL"
        fi

        pubkey=$(grep "public key" "$keyfile" | awk '{print $4}')
        echo "Public key for $ENV: $pubkey"

        touch .sops.yaml
        if ! grep -q "path_regex: envs/$ENV/secrets\\.ya" .sops.yaml 2>/dev/null; then
          printf "  - path_regex: envs/%s/secrets\\.ya?ml\$\n    age: %s\n" "$ENV" "$pubkey" >> .sops.yaml
        fi

        echo "Added creation rule for $ENV in .sops.yaml"

  sops:copy-dev-keys:
    desc: Copy dev sops keys
    cmds:
      - cp .sops/dev/key.txt.example .sops/dev/key.txt
      - |
        if [ ! -f .sops.yaml ]; then 
          cp .sops.example.yaml .sops.yaml
        fi
      - |
        if [ ! -f ./envs/dev/secrets.yaml ]; then 
          cat "---" > ./envs/dev/secrets.yaml
        fi

  dev:skaffold-build-image:*:
    desc: "Build and deploy a service locally. Set SERVICES_BASEPATH to your repos root (default: ..)"
    vars:
      SERVICE: "{{ index .MATCH 0 }}"
      BASEPATH: '{{ env "SERVICES_BASEPATH" | default "../celine-dev/repositories" }}'
      REPO_PATH: '{{ env "REPO_PATH" | default "" }}'
      IMAGE_NAME: '{{ env "IMAGE_NAME" | default "" }}'
    env:
      SOPS_AGE_KEY_FILE: "{{.PWD}}/.sops/dev/key.txt"
    cmds:
      - |

        REPO_PATH={{ if .REPO_PATH }}{{ .REPO_PATH }}{{ else }}{{.BASEPATH}}/{{.SERVICE}}{{ end }}
        IMAGE_NAME={{ if .IMAGE_NAME }}{{ .IMAGE_NAME }}{{ else }}{{.SERVICE}}{{ end }}
        SERVICE_NAME={{ if .SERVICE_NAME }}{{ .SERVICE_NAME }}{{ else }}{{.SERVICE}}{{ end }}

        eval $(minikube docker-env) && docker build -t ghcr.io/celine-eu/{{.SERVICE}}:local $REPO_PATH

        helmfile -e dev -l name={{.SERVICE}} apply \
          --set image.tag=local \
          --set image.pullPolicy=Never
        kubectl rollout restart deployment/{{.SERVICE}} -n celine-dev

  dev:build:rec-registry:
    cmds:
      - task dev:skaffold-build-image:rec-registry

  dev:build:nudging:
    cmds:
      - REPO_PATH="../celine-dev/repositories/nudging-tool" task dev:skaffold-build-image:nudging

  dev:build:digital-twin:
    cmds:
      - REPO_PATH="../celine-dev/repositories/digital-twin" task dev:skaffold-build-image:digital-twin

  dev:build:dataset-api:
    cmds:
      - REPO_PATH="../celine-dev/repositories/dataset-api" task dev:skaffold-build-image:dataset-api

  dev:build:policies-shell:
    cmds:
      - |
        IMAGE_NAME=celine-policies \
        SERVICE_NAME=policies-shell \
        REPO_PATH="../celine-dev/repositories/celine-policies" \
        task dev:skaffold-build-image:policies-shell
